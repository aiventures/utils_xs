"""transforms json structures to flattened json structure for usage with ExifTool
List of XMP Fields  https://exiftool.org/TagNames/XMP.html
List of IPTC Fields https://exiftool.org/TagNames/IPTC.html
        IPTC SPECS  https://iptc.org/standards/photo-metadata/iptc-standard/
        => "XMP exif Tags"
        => "XMP LocationDetails Struct"
        Note that the GPS elements of this structure are in the "exif" namespace.

For the dict structure to be generated by exiftool, use the command
exiftool -json -g -c '%.6f' *.jpg > makernotes.json

"""

import os
import json

from typing import Any, Optional, Tuple, Literal
from datetime import datetime as DateTime
from libs.geo import Geo, HEARTRATE, TEMPERATURE, ELEVATION, DATETIME
from libs.helper import Persistence

# custom print commands / note that MY_ENV_PRINT_SHOW_EMOJI and MY_ENV_PRINT_SHOW_EMOJI
# need to be set accordingly in environment to reflect certain debug levels
from libs.custom_print import printe, printw, print_json
from config.colors import C_0, C_E, C_Q, C_I, C_T, C_PY, C_P, C_H, C_B, C_F, C_W


# get some properties from the environment / define it in the setenv.bat or a bash
# initialization script respectively. Use the template in /templates/myenv_template.bat
EXIFTOOL_AUTHOR = os.environ.get("MY_EXIFTOOL_AUTHOR", "UNKNOWNN AUTHOR")
EXIFTOOL_BYLINE_TITLE = os.environ.get("MY_EXIFTOOL_AUTHORTITLE", "Honorable")

# this is the expected sample json based on exiftool reverse geo API
SAMPLE_EXIFREVERSE = {
    "sample": {
        "geotrack_origin": "gpx",
        "metadata_geo": {
            "idx": 1,
            "file": "....",
            "lat_lon": [49.119948, 8.787893],
            "geo_reverse": {
                "GeolocationCity": "Zaisenhausen",
                "GeolocationRegion": "Baden-WÃ¼rttemberg",
                "GeolocationSubregion": "Regierungsbezirk Karlsruhe",
                "GeolocationCountryCode": "DE",
                "GeolocationCountry": "Bundesrepublik Deutschland",
                "GeolocationTim0eZone": "Europe/Berlin",
                "GeolocationFeatureCode": "PPLA4",
                "GeolocationFeatureType": "Seat of a Fourth-order Administrative Division",
                "GeolocationPopulation": 1800,
                "GeolocationPosition": "49.1067, 8.8128",
                "GeolocationDistance": "2.32 km",
                "GeolocationBearing": 118,
            },
            "geo_info": "2.32 km, 118Â° to Zaisenhausen/Regierungsbezirk Karlsruhe/Baden-WÃ¼rttemberg",
            "time_zone": "Europe/Berlin",
        },
        "gps_info": {
            "datetime_camera_exif": "2025:08:31 16:04:26.73+02:00",
            "offset": -286,
            "datetime_camera_utc": "2025-08-31T13:59:40.730000+00:00",
            "datetime_gps_utc": "2025-08-31T13:59:42+00:00",
            "timestamp_camera": 1756648780730,
            "timestamp_gps": 1756648782000,
            "timestamp_diff": -1.27,
        },
    }
}


# Note depending on category theres's diferent address attributes
# https://nominatim.org/release-docs/develop/api/Reverse/
# https://nominatim.org/release-docs/latest/api/Output/#addressdetails

# Examples
# City Place:
# https://www.openstreetmap.org/#map=17/48.778175/9.181369
# https://nominatim.openstreetmap.org/reverse?lat=48.778175&lon=9.181369&format=json&addressdetails=17
# {
#     "osm_type": "node",
#     "class": "tourism",
#     "type": "artwork",
#     "addresstype": "tourism",
#     "name": "Herkules",
#     "display_name": "Herkules, Leopoldo-Retti-Weg, Oberer Schlossgarten, Stuttgart-Mitte, Stuttgart, Baden-WÃ¼rttemberg, 70173, Deutschland",
#     "address": {
#         "tourism": "Herkules",
#         "road": "Leopoldo-Retti-Weg",
#         "neighbourhood": "Oberer Schlossgarten",
#         "suburb": "Stuttgart-Mitte",
#         "city": "Stuttgart",
#         "state": "Baden-WÃ¼rttemberg",
#         "ISO3166-2-lvl4": "DE-BW",
#         "postcode": "70173",
#         "country": "Deutschland",
#         "country_code": "de"
#     },
# }

# City Building
# https://www.openstreetmap.org/#map=19/48.780727/9.191953
# https://nominatim.openstreetmap.org/reverse?lat=48.780727&lon=9.191953&format=json&addressdetails=17
# {
#     "osm_type": "way",
#     "class": "building",
#     "place_rank": 30,
#     "addresstype": "building",
#     "name": "",
#     "display_name": "30, HauÃŸmannstraÃŸe, Kernerviertel, Stuttgart-Mitte, Stuttgart, Baden-WÃ¼rttemberg, 70188, Deutschland",
#     "address": {
#         "house_number": "30",
#         "road": "HauÃŸmannstraÃŸe",
#         "neighbourhood": "Kernerviertel",
#         "suburb": "Stuttgart-Mitte",
#         "city": "Stuttgart",
#         "state": "Baden-WÃ¼rttemberg",
#         "ISO3166-2-lvl4": "DE-BW",
#         "postcode": "70188",
#         "country": "Deutschland",
#         "country_code": "de"
#     },
# }

# Village
# https://www.openstreetmap.org/#map=19/48.630626/9.155566
# https://nominatim.openstreetmap.org/reverse?lat=48.630626&lon=9.15566&format=json&addressdetails=17
# {
#     "class": "building",
#     "addresstype": "building",
#     "display_name": "13, Wacholderweg, GlashÃ¼tte, Waldenbuch, Gemeindeverwaltungsverband Waldenbuch/Steinenbronn, Landkreis BÃ¶blingen, Baden-WÃ¼rttemberg, 71111, Deutschland",
#     "address": {
#         "house_number": "13",
#         "road": "Wacholderweg",
#         "village": "GlashÃ¼tte",
#         "town": "Waldenbuch",
#         "municipality": "Gemeindeverwaltungsverband Waldenbuch/Steinenbronn",
#         "county": "Landkreis BÃ¶blingen",
#         "state": "Baden-WÃ¼rttemberg",
#         "ISO3166-2-lvl4": "DE-BW",
#         "postcode": "71111",
#         "country": "Deutschland",
#         "country_code": "de"
#     },
# }

# Forest Way
# https://www.openstreetmap.org/#map=18/48.623539/9.153958
# https://nominatim.openstreetmap.org/reverse?lat=48.623539&lon=9.153958&format=json&addressdetails=17
# {
#     "class": "tourism",
#     "addresstype": "tourism",
#     "display_name": "Vom Suchen und Finden, DettenhÃ¤user Weg, Aichtal, Landkreis Esslingen, Baden-WÃ¼rttemberg, 72631, Deutschland",
#     "address": {
#         "tourism": "Vom Suchen und Finden",
#         "road": "DettenhÃ¤user Weg",
#         "municipality": "Aichtal",
#         "county": "Landkreis Esslingen",
#         "state": "Baden-WÃ¼rttemberg",
#         "ISO3166-2-lvl4": "DE-BW",
#         "postcode": "72631",
#         "country": "Deutschland",
#         "country_code": "de"
#     },
# }

SAMPLE_GEOREVERSE = {
    "sample": {
        "place_id": 415916694,
        "licence": "Data Â© OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright",
        "osm_type": "way",
        "osm_id": 30045902,
        "lat": "49.1199546",
        "lon": "8.7878757",
        "category": "highway",
        "type": "unclassified",
        "place_rank": 26,
        "importance": 0.05338245441367205,
        "addresstype": "road",
        "name": "",
        "display_name": "BahnbrÃ¼cken, Rohrbach am GieÃŸhÃ¼bel, BahnbrÃ¼cken, Kraichtal, Landkreis Karlsruhe, Baden-WÃ¼rttemberg, 76703, Deutschland",
        "address": {
            "suburb": "BahnbrÃ¼cken",
            "village": "Rohrbach am GieÃŸhÃ¼bel",
            "municipality": "Kraichtal",
            "county": "Landkreis Karlsruhe",
            "state": "Baden-WÃ¼rttemberg",
            "ISO3166-2-lvl4": "DE-BW",
            "postcode": "76703",
            "country": "Deutschland",
            "country_code": "de",
        },
        "boundingbox": ["49.1199335", "49.1344446", "8.7878690", "8.8526804"],
        "extra": {
            "FileName": "20250831_BahnbrÃ¼cken_0136.jpg",
            "timestamp_utc": 1756648782000,
            "timezone": "Europe/Berlin",
            "datetime": "2025:08:31 15:59:42",
            "elevation": 209,
            "heartrate": 127,
        },
    }
}

# Tags to be Populated from EXIFTOOL / Example
# Use the following commands as batch file to remove and recreate metadata
# for test.jpg file
# echo delete metadata
# exiftool -all= test.jpg
# exiftool -json test.jpg -G1 -c '%.6f'
# echo update metadata
# exiftool -overwrite_original -json=test.json test.jpg
# exiftool -json test.jpg -G1 -c '%.6f'
# echo show hugo segments
# exiftool -json test.jpg -G1 -c '%.6f' | grep -i hugo
SAMPLE_METADATA_EXIFTOOL_TAGS = [
    {
        "SourceFile": "test.jpg",
        # IFD Segment https://exiftool.org/TagNames/EXIF.html
        "ImageTitle": "hugoImageTitle ExifIFD",  # MAPPED
        "ImageDescription": "HugoImageDescription_ifd0",  # MAPPED
        # GPS Segment https://exiftool.org/TagNames/GPS.html
        "GPSLatitude": 48.123456,  # MAPPED
        "GPSLatitudeRef": "N",  # MAPPED
        "GPSLongitude": 8.765432,  # MAPPED
        "GPSLongitudeRef": "E",  # MAPPED
        "GPSAltitude": 120.5,  # MAPPED
        "GPSAltitudeRef": 1,  # MAPPED
        # IPTC Segment https://exiftool.org/TagNames/IPTC.html
        # the following IPTC attributes are also used in the IRFAN VIEW TABS
        # IRFAN Description TAB
        "ObjectName": "hugoObjectName IPTC",  # MAPPED
        "By-lineTitle": "hugo by-line title IPTC",  # MAPPED
        "By-line": "hugo by-line Henrik Fessler_IPTC",  # MAPPED
        "CopyrightNotice": "(C) HUGO COPYRIGHT NOTICE IPTC",  # MAPPED
        "Caption-Abstract": "HUGO CAPTION ABSTRACT Longtext IPTC",  # MAPPED
        "Writer-Editor": "HUGO WRITER EDITOR IPTC",  # MAPPED
        "Headline": "hugoheadline IPTC",  # MAPPED
        "SpecialInstructions": "HugoSpecialInstructions IPTC",  # MAPPED
        # IRFAN KEYWORDS TAB
        "Keywords": ["hugo1 IPTC", "hugo2"],
        "Category": "XYZ",  # only three letters # MAPPED to NT1
        "SupplementalCategories": ["hugo sup1 iptc"],  # NOT SUPPLIED
        "Urgency": 6,  # MAPPED To 6
        # IRFAN Credits/Origin Tab
        "Credit": "HUGO CREDIT IPTC",  # MAPPED
        "Source": "HugoSource_IPTC",  # mapped to own photography
        "DateCreated": "2099:03:29 23:55:58 IPTC",  # MAPPED
        "City": "HugoCity_IPTC",  # MAPPED
        "Sub-location": "HUGO SUB LOCATION_IPTC",
        "Province-State": "HUGO Baden-WÃ¼rttemberg IPTC",  # MAPPED
        "Country-PrimaryLocationName": "HUGO PRIMARY LOCATION NAME IPTC",  # MAPPED
        "OriginalTransmissionReference": "HUGOI TRANSMISSION timedate IPTC",  # MAPPED
        # OTHER IPTC
        "Country-PrimaryLocationCode": "de",  # MAPPED
        ###### XMP https://exiftool.org/TagNames/XMP.html
        # XMP Photoshop
        "CaptionWriter": "Hugo Caption Writer xmp photoshop",  # MAPPED
        "Country": "HugoDeutshcland_xmp_photoshop_country",  # MAPPED
        # XMP iptcCore
        "CountryCode": "de",  # MAPPED
        "Location": "HugoLocation_xmp_iptcCore",  # MAPPED
        "CreatorWorkURL": "hugocreatorworkurl__xmp_iptcCore",  # MAPPED
        "IntellectualGenre": "hugoIntellectualGenre XMP-iptcCore",  # MAPPED
        # XMP DC
        "Contributor": "HugoContributor_xmp_dc",  # MAPPED
        "Creator": "HugoCreator_xmp_dc",  # MAPPED
        "Description": "HugoDescription_xmp_dc",  # MAPPED
        "Rights": "HugoRights_xmp_dc",  # MAPPED
        "Subject": "HugoSubject_xmp_dc",  # MAPPED
        "Title": "HugoTitle_xmp_dc",  # MAPPED
        # XMP-xmp
        "Rating": 3,  # MAPPED
        "BaseURL": "hugobaseurl_xmp_xmp",  # MAPPED
    }
]

# ATTRIBUTES TO BE USED
FILE = "file"
AUTHOR = "author"
AUTHORTITLE = "authortitle"
RIGHTS = "rights"
COPYRIGHT = "copyright"
URGENCY = "urgency"
SOURCE = "source"
RATING = "rating"
ORIGINAL_TRANSMISSION_REF = "original_transmission_ref"

# Segments
EXIF = "EXIF"

# https://www.iptc.org/std/photometadata/documentation/userguide/#_intellectual_genre_legacy
GENRE = "genre"
DATE_CREATED = "date_created"
KEYWORDS = "keywords"

# IPTC Category NT1 https://vocabularyserver.com/mediatopic/index.php?tema=1&/arts-culture-and-entertainment
IPTC_CATEGORY = "iptc_category"
DESCRIPTION = "description"
DATETIME = "datetime"
GPS_DATETIME = "gpsdatetime"
GPS_DATE = "gpsdate"
GPS_TIME = "gpstime"
TIMEZONE = "timezone"
COUNTRY = "country"
COUNTRY_CODE = "country_code"
STATE = "state"
ZIP_CODE = "zip_code"
SUBREGION = "subregion"
LOCATION = "location"
CITY = "city"
METADATA_GEO = "metadata_geo"
GEO_URL = "geo_url"

UNKNOWN = "unknown"
DLUX = "lux"
FUJI = "fuji"
LAT = "lat"
LON = "lon"
LATLON = "latlon"
LAT_ORIENTATION = "lat_orientation"
LON_ORIENTATION = "lon_orientation"
ELEVATION = "elevation"
ELEVATION_REF = "elevation_ref"

# labels to extract dta from json
METADATA_SEGMENT = [METADATA_GEO, "address"]
COUNTRY_LABELS = ["GeolocationCountry", "country"]
COUNTRYCODE_LABELS = ["GeolocationCountryCode", "country_code"]
STATE_LABELS = ["GeolocationRegion", "state"]
ZIP_LABELS = ["postcode"]
# for nominatim the json definitions are a bit sketchy so we'll take a first match approach here
SUBREGION_LABELS = ["GeolocationSubregion", "municipality", "county", "suburb", "city", "town", "village", "hamlet"]
CITY_LABELS = ["GeolocationCity", "city", "village", "town", "hamlet"]

# MAP To Populate EXIFTOOL Metadata fields from input fields
EXIFTOOL_MAP = {
    # fixed values
    FILE: ["SourceFile"],
    AUTHOR: ["By-line", "Writer-Editor", "Creator", "Contributor", "Credit", "CaptionWriter"],
    AUTHORTITLE: ["By-lineTitle"],
    COPYRIGHT: ["CopyrightNotice"],
    IPTC_CATEGORY: ["Category"],
    GENRE: ["IntellectualGenre"],
    URGENCY: ["Urgency"],
    RATING: ["Rating"],
    RIGHTS: ["Rights"],
    ORIGINAL_TRANSMISSION_REF: ["OriginalTransmissionReference"],
    DATE_CREATED: ["DateCreated"],
    GPS_DATETIME: ["GPSDateTime"],
    GPS_DATE: ["GPSDateStamp"],
    GPS_TIME: ["GPSTimeStamp"],
    DESCRIPTION: [
        "ImageTitle",
        "ImageDescription",
        "ObjectName",
        "Caption-Abstract",
        "Headline",
        "Title",
        "Subject",
        "Description",
    ],
    LAT: ["GPSLatitude"],
    LON: ["GPSLongitude"],
    LAT_ORIENTATION: ["GPSLatitudeRef"],
    LON_ORIENTATION: ["GPSLongitudeRef"],
    ELEVATION: ["GPSAltitude"],
    ELEVATION_REF: ["GPSAltitudeRef"],
    GEO_URL: ["SpecialInstructions", "BaseURL", "CreatorWorkURL"],
    COUNTRY: ["Country-PrimaryLocationName", "Country"],
    COUNTRY_CODE: ["CountryCode", "Country-PrimaryLocationCode"],
    STATE: ["Province-State"],
    LOCATION: ["City", "Location"],
    # not needed right now
    # KEYWORDS:["Keywords"]
    # ZIP_CODE: [],
    # SUBREGION: [],
}


# map to export to IPTC Fields
METADATA_IPTC_MAP = {
    "CodedCharacterSet": None,  # TODO MAP THIS AS WELL
    "EnvelopeRecordVersion": None,
    "Caption-Abstract": DESCRIPTION,
    "Writer-Editor": AUTHOR,
    "Headline": DESCRIPTION,
    "SpecialInstructions": GEO_URL,
    "By-line": AUTHOR,
    "By-lineTitle": AUTHORTITLE,
    "Credit": AUTHOR,
    "Source": SOURCE,
    "ObjectName": LOCATION,
    "DateCreated": DATE_CREATED,
    "City": CITY,
    "Sub-location": LOCATION,
    "Province-State": STATE,
    "Country-PrimaryLocationName": COUNTRY,
    "OriginalTransmissionReference": ORIGINAL_TRANSMISSION_REF,
    "Category": IPTC_CATEGORY,
    "SupplementalCategories": None,
    "Urgency": URGENCY,
    "Keywords": KEYWORDS,
    "CopyrightNotice": COPYRIGHT,
}


class GeoMetaTransformer:
    """class to transform geo data"""

    def __init__(
        self,
        filename: str,
        meta_dict: dict,
        image_geo_info: Optional[dict] = None,
        image_reverse_geo_info: Optional[dict] = None,
        gps_track: Optional[dict] = None,
        file_path: Optional[str] = None,
        datetime_created: Optional[DateTime] = None,
        keywords: Optional[list[str]] = None,
        map_exif2keywords: bool = True,
    ):
        """Constructor"""
        if not isinstance(meta_dict, dict):
            printe(f"[GeoTransformer] No Metadata transfered for file {C_F}[{filename}]")
            return

        # filename
        self._filename: str = filename
        # gets the meta dict
        self._meta_dict: dict = meta_dict
        # gets sub structures of metadata
        self._meta_exif: dict = meta_dict.get(EXIF, {})

        self._meta_makernotes: dict = self._meta_exif.get("MakeNotes", {})
        self._make = UNKNOWN
        _make: str = self._meta_exif.get("Make", UNKNOWN).lower()
        _model: str = self._meta_exif.get("Model", UNKNOWN).lower()

        if DLUX in _model:
            self._make = DLUX
        elif FUJI in _make:
            self._make = FUJI

        # geo info as retrieved from exiftool reverse geo
        # get the geo reverse
        #  {
        #     "geotrack_origin": "gpx",
        #     "metadata_geo": {
        #         "idx": 1,
        #         "file": "C:/Users/Henrik/Desktop/gps_test_files/test_single/gps.jpg",
        #         "lat_lon": [
        #             49.119324,
        #             8.79133
        #         ],
        #         "geo_reverse": {
        #             "GeolocationCity": "Zaisenhausen",
        #             "GeolocationRegion": "Baden-WÃ¼rttemberg",
        #             "GeolocationSubregion": "Regierungsbezirk Karlsruhe",
        #             "GeolocationCountryCode": "DE",
        #             "GeolocationCountry": "Bundesrepublik Deutschland",
        #             "GeolocationTimeZone": "Europe/Berlin",
        #             "GeolocationFeatureCode": "PPLA4",
        #             "GeolocationFeatureType": "Seat of a Fourth-order Administrative Division",
        #             "GeolocationPopulation": 1800,
        #             "GeolocationPosition": "49.1067, 8.8128",
        #             "GeolocationDistance": "2.10 km",
        #             "GeolocationBearing": 121
        #         },
        #         "geo_info": "2.10 km, 121Â° to Zaisenhausen/Regierungsbezirk Karlsruhe/Baden-WÃ¼rttemberg",
        #         "time_zone": "Europe/Berlin"
        #     },
        #     "gps_info": {
        #         "datetime_camera_exif": "2025:08:31 16:34:46.22+02:00",
        #         "offset": 0,
        #         "datetime_camera_utc": "2025-08-31T14:34:46.220000+00:00",
        #         "datetime_gps_utc": "2025-08-31T14:34:47+00:00",
        #         "timestamp_camera": 1756650886220,
        #         "timestamp_gps": 1756650887000,
        #         "timestamp_diff": -0.78
        #     }
        # }
        self._image_geo_info: Optional[dict] = image_geo_info
        self._image_geo_address: dict = (
            {}
            if not isinstance(image_geo_info, dict)
            else image_geo_info.get("metadata_geo", {}).get("geo_reverse", {})
        )

        # geo info as retrieved from reverse geo api
        #  {
        #     "place_id": 113798192,
        #     "licence": "Data Â© OpenStreetMap contributors, ODbL 1.0. http://osm.org/copyright",
        #     "osm_type": "way",
        #     "osm_id": 31066248,
        #     "lat": "49.1191423",
        #     "lon": "8.7889975",
        #     "category": "highway",
        #     "type": "residential",
        #     "place_rank": 26,
        #     "importance": 0.05338669336995495,
        #     "addresstype": "road",
        #     "name": "WeiherstraÃŸe",
        #     "display_name": "WeiherstraÃŸe, BahnbrÃ¼cken, Kraichtal, Landkreis Karlsruhe, Baden-WÃ¼rttemberg, 76703, Deutschland",
        #     "address": {
        #         "road": "WeiherstraÃŸe",
        #         "suburb": "BahnbrÃ¼cken",
        #         "village": "BahnbrÃ¼cken",
        #         "municipality": "Kraichtal",
        #         "county": "Landkreis Karlsruhe",
        #         "state": "Baden-WÃ¼rttemberg",
        #         "ISO3166-2-lvl4": "DE-BW",
        #         "postcode": "76703",
        #         "country": "Deutschland",
        #         "country_code": "de"
        #     },
        #     "boundingbox": [
        #         "49.1189961",
        #         "49.1191423",
        #         "8.7877008",
        #         "8.7889975"
        #     ],
        #     "extra": {
        #         "FileName": "xxx.jpg",
        #         "timestamp_utc": 1756650887000,
        #         "timezone": "Europe/Berlin",
        #         "datetime": "2025:08:31 16:34:47",
        #         "elevation": 241,
        #         "heartrate": 136
        #     }
        # }
        self._image_reverse_geo_info: Optional[dict] = image_reverse_geo_info
        self._image_reverse_geo_address: dict = (
            {} if not isinstance(image_reverse_geo_info, dict) else image_reverse_geo_info.get("address")
        )

        # gps_track entry
        self._gps_track: Optional[dict] = gps_track

        # authors
        self._author = EXIFTOOL_AUTHOR
        self._authortitle = EXIFTOOL_BYLINE_TITLE
        # path of the file
        self._file_path = file_path
        # datetime created
        self._datetime_created = datetime_created
        # keywords
        self._keywords: Optional[list[str]] = keywords
        # fla: automatically map some of the exif data as keywords
        map_exif2keywords: bool = map_exif2keywords
        # flag if reverse geo metadata is from exiftool (true) or from nominatim (false)
        self._geo_metadata_type: Literal["exiftool", "georeverse_api", "undefined"] = "undefined"
        self._address_segment: dict = {}
        self._meta_geo: dict = self._get_geo_meta()
        if self._geo_metadata_type == "undefined":
            printe("[GeoMetaTransformer] No Proper Geo Metadata detected")

        # map standard EXIF darta to keywords automatically
        # TODO  ðŸš¨Implement
        self._map_exif2keywords: bool = map_exif2keywords

    def _get_geo_meta(self) -> Optional[dict]:
        """gets the address metadata from meta dictionary depending on passed type"""
        if isinstance(self._image_reverse_geo_info, dict):
            self._geo_metadata_type = "georeverse_api"
            self._address_segment = self._image_reverse_geo_info.get("address", {})
            return self._image_reverse_geo_info
        elif isinstance(self._image_geo_info, dict):
            self._geo_metadata_type = "exiftool"
            self._address_segment = self._image_geo_info.get("geo_reverse", {})
            return self._image_geo_info
        return None

    def get_display_name(self) -> str:
        """gets the long display name from the meta data"""
        if self._geo_metadata_type == "exiftool":
            return self._meta_geo.get("display_name", "NO DISPLAY NAME")
        elif self._geo_metadata_type == "georeverse_api":
            return self._meta_geo.get("display_name")

        return "NO DISPLAY NAME"

    def get_value_from_meta(self, attribute_list: list[str]) -> Optional[Any]:
        """Gets a value from a dict upon first occurence of a value"""
        for attribute in attribute_list:
            if self._meta_dict.get(attribute) is not None:
                return self._meta_dict.get(attribute)
        return None

    def _get_gps_data_exiftool(self) -> Optional[Tuple[float, float, float]]:
        """gets the lat lon altitude coordinates from exiftool geo reverse"""
        if self._geo_metadata_type != "exiftool":
            return None

        try:
            lat, lon = self._meta_geo.get("lat_lon")
            lat = float(lat)
            lon = float(lon)
        except (ValueError, IndexError):
            printw("[GeoTransformer] GPS Data No latlon information available ")
            return None
        # get altitude from gps data if present
        elevation = 0.0
        if isinstance(self._gps_track, dict):
            elevation = self._gps_track.get("ele", 0, 0)

        return (lat, lon, elevation)

    def _get_gps_data_georeverse(self) -> Optional[Tuple[float, float, float]]:
        """gets the lat lon altitude coordinates from exiftool geo reverse"""
        if self._geo_metadata_type != "georeverse_api":
            return None

        try:
            lat = float(self._image_reverse_geo_info.get("lat"))
            lon = float(self._image_reverse_geo_info.get("lat"))
            ele = float(self._meta_dict.get("extra", {}).get("elevation", 0.0))
        except (ValueError, IndexError):
            printe("[GeoTransformer] GPS Data Conversion error ")
            return None
        return (lat, lon, ele)

    def get_gps_data(self) -> Optional[Tuple[float, float, str, str, float]]:
        """returns lat,lon,orientation lat lon,altitude geo data from any passedf gps datas"""

        if not isinstance(self._gps_track, dict):
            return None

        lat = None
        lon = None
        elevation = None

        try:
            lat = round(float(self._gps_track["lat"]), 6)
            lon = round(float(self._gps_track["lon"]), 6)
            elevation = int(round(float(self._gps_track["ele"]), 0))
        # try exifreverse data first
        except (ValueError, IndexError):
            printe("[GeoTransformer] No Valid GPS Data found ")
            return None

        lat_orientation = "N" if lat >= 0 else "S"
        lon_orientation = "E" if lat >= 0 else "W"
        return (lat, lon, lat_orientation, lon_orientation, elevation)

    def get_gps_extra(self) -> dict:
        """Returns additional extra metadata like heartrate and temperature"""
        if not isinstance(self._gps_track, dict):
            return {}

        # for now hardcoded values from gps_track format
        heartrate = self._gps_track.get("extensions_trackpointextension_hr")
        temperature = self._gps_track.get("extensions_trackpointextension_atemp")
        elevation = self._gps_track.get("ele")
        datetime_ = self._gps_track.get("time")

        out = {HEARTRATE: heartrate, TEMPERATURE: temperature, ELEVATION: elevation, DATETIME: datetime_}
        out = {k: v for (k, v) in out.items() if v is not None}
        # convert to int
        for k, v in out.items():
            if k in [HEARTRATE, ELEVATION, TEMPERATURE]:
                try:
                    v_ = int(v)
                    out[k] = v_
                except (AttributeError, ValueError, TypeError):
                    pass
        return out

    def get_timezone(self) -> Optional[str]:
        """Gets the Timezone From either exiftool or geo reverse"""
        _timezone = self._image_geo_address.get("GeolocationTimeZone")
        if _timezone is None:
            _timezone = self._image_reverse_geo_address.get("extra", {}).get("timezone")
        return _timezone

    def transform(self) -> dict:
        """gets the labels from the the metadata segment
        and returns the output dict with correct EXIFTOOL LABELS
        works for both types of
        address metadata
        """

        def map_meta_value(fields: list, data_dict: dict) -> Optional[Any]:
            """maps fields from the dict.
            Upon first non empty occurence this value is returned"""
            for field in fields:
                value = data_dict.get(field)
                if value is not None:
                    return value
            return None

        out = {}

        lat = None
        lon = None
        lat_orientation = None
        lon_orientation = None
        elevation = None

        gps_data = self.get_gps_data()
        latlon = None
        if gps_data is not None:
            lat, lon, lat_orientation, lon_orientation, elevation = gps_data
            latlon = f"{str(lat)}{lat_orientation} {str(lon)}{lon_orientation}"

        display_name = self.get_display_name()
        geo_url = None if lat is None else Geo.latlon2osm((lat, lon))
        datetime_meta = self._datetime_created
        if datetime_meta is None:
            datetime_meta = DateTime.now()
        year = datetime_meta.strftime("%Y")
        datetime_meta_s = datetime_meta.strftime("%Y-%m-%d %H:%M:%S")
        # -GPSDateTime="2024:12:31 23:59:59"
        # -GPSDateStamp="2024:12:31"
        # -GPSTimeStamp="23:59:59"
        gps_date_time = datetime_meta.strftime("%Y:%m:%d %H:%M:%S")
        gps_date = datetime_meta.strftime("%Y:%m:%d")
        gps_time = datetime_meta.strftime("%H:%M:%S")
        copyright_ = f"(C) Copyright {str(year)} {self._author} "
        # IPTC Category always set to NT1 arts, culture and entertainme
        iptc_category = "NT1"
        # Urgency always set to normal
        urgency = 6
        # rating always set to 3
        rating = 3
        source = "own photography"
        rights = f"(C) {str(year)} ALL RIGHTS RESERVED"
        # misusing the genre metadata
        genre = "leisure photography"
        transmission_reference = f"{datetime_meta_s}"
        # filename
        filename = self._filename
        # gps_extra: Temperature, Heartrate,etc
        gps_extra: dict = self.get_gps_extra()
        # timezone
        timezone = self.get_timezone()

        field_map = {
            # fixed values
            FILE: filename,
            AUTHOR: self._author,
            AUTHORTITLE: self._authortitle,
            SOURCE: source,
            COPYRIGHT: copyright_,
            RIGHTS: rights,
            DESCRIPTION: display_name,
            IPTC_CATEGORY: iptc_category,
            TIMEZONE: timezone,
            DATE_CREATED: datetime_meta_s,
            GPS_DATE: gps_date,
            GPS_TIME: gps_time,
            GPS_DATETIME: gps_date_time,
            URGENCY: urgency,
            RATING: rating,
            GENRE: genre,
            ORIGINAL_TRANSMISSION_REF: transmission_reference,
            DATETIME: datetime_meta_s,
            LATLON: latlon,
            LAT: lat,
            LON: lon,
            LAT_ORIENTATION: lat_orientation,
            LON_ORIENTATION: lon_orientation,
            ELEVATION: elevation,
            ELEVATION_REF: 1,  # elevation set to above 0 in all cases
            HEARTRATE: gps_extra.get(HEARTRATE),
            TEMPERATURE: gps_extra.get(TEMPERATURE),
            GEO_URL: geo_url,
            # determine
            COUNTRY: COUNTRY_LABELS,
            COUNTRY_CODE: COUNTRYCODE_LABELS,
            STATE: STATE_LABELS,
            # there is no zip code
            ZIP_CODE: ZIP_LABELS,
            SUBREGION: SUBREGION_LABELS,
            LOCATION: CITY_LABELS,
            # add specific makernotes
        }

        # add keywords if populated
        if isinstance(self._keywords, list):
            field_map[KEYWORDS] = self._keywords

        for field, value in field_map.items():
            out_value = value
            # for now lists only contain field lists
            # later on we might also consider keyword lists
            if field not in [KEYWORDS]:
                if isinstance(value, list):
                    out_value = map_meta_value(value, self._address_segment)

            if out_value is None:
                continue
            out[field] = out_value

        return out

    @staticmethod
    def get_iptc_metadata(exiftool_metadata: dict) -> dict:
        """gets the results from the transform() method and exports them as
        supported IPTC values, so that it can be used to get keywords
        """

        out = {}

        # reverse the metadata dictionary to IPTC metadata
        for iptc_key, metadata_key in METADATA_IPTC_MAP.items():
            value = exiftool_metadata.get(metadata_key)
            if value is None:
                continue
            out[iptc_key] = value

        return out

    @staticmethod
    def dict_key_paths(data: dict, prefix=None, name=None) -> list:
        """transforms a dict into a list of key paths"""
        if prefix is None:
            prefix = []

        paths = []
        for key, value in data.items():
            new_prefix = prefix + [key]
            if isinstance(value, dict):
                paths.extend(GeoMetaTransformer.dict_key_paths(value, new_prefix))
            else:
                paths.append(new_prefix)
        out = {"paths": paths}

        return paths

    @staticmethod
    def extract_key_lists(data):
        """Return a dict mapping each key to a list of its immediate child keys."""
        out = {}
        for key, value in data.items():
            if isinstance(value, dict):
                out[key] = list(value.keys())
            else:
                out[key] = []
        return out


if __name__ == "__main__":
    # just show the pathscls
    # GeoMetaTransformer._dict_key_paths(SAMPLE_EXIFREVERSE["sample"], name="SAMPLE_EXIFREVERSE")
    # print(list(SAMPLE_METADATA_EXIFTOOL_TAGS[0].keys()))
    pass
    f = r"...\keywords.json"
    d = Persistence.read_json(f)
    GeoMetaTransformer.extract_key_lists(d[0])
    # GeoMetaTransformer.extract_key_lists(d[1])
